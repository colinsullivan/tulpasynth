<HTML>
<HEAD>
<TITLE>The Synthesis ToolKit in C++ (STK)</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<img src="princeton.gif"> &nbsp; <img src="ccrma.gif"> &nbsp; <img src="mcgill.gif"><P>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="information.html">Information</a> &nbsp; <a class="qindex" href="classes.html">Classes</a> &nbsp; <a class="qindex" href="download.html">Download</a> &nbsp; <a class="qindex" href="usage.html">Usage</a> &nbsp; <a class="qindex" href="maillist.html">Mail List</a> &nbsp; <a class="qindex" href="system.html">Requirements</a> &nbsp; <a class="qindex" href="links.html">Links</a> &nbsp; <a class="qindex" href="faq.html">FAQ</a> &nbsp; <a class="qindex" href="tutorial.html">Tutorial</a></CENTER>
<HR>
<!-- Generated by Doxygen 1.6.2 -->
<div class="contents">


<h1><a class="anchor" id="polyvoices">Voice Management </a></h1><p>The previous tutorial chapters were concerned only with monophonic ToolKit instrument playback and control. At this point, it should be relatively clear that one can instantiate multiple instruments and perhaps sum together their outputs or even direct their outputs to separate channels. It is less clear how one might go about controlling a group of instruments. The <a class="el" href="classstk_1_1Voicer.html" title="STK voice manager class.">stk::Voicer</a> class is designed to serve just this purpose.</p>
<p>The <a class="el" href="classstk_1_1Voicer.html" title="STK voice manager class.">stk::Voicer</a> class is a relatively simple voice manager. The user can dynamically add and delete instruments to/from its "control", with the option of controlling specific instruments via unique note tags and/or grouping sets of instruments via a "group" number. All sounding instrument outputs are summed and returned via the <code>tick()</code> function. The <a class="el" href="classstk_1_1Voicer.html" title="STK voice manager class.">stk::Voicer</a> class responds to noteOn, noteOff, setFrequency, pitchBend, and controlChange messages, automatically assigning incoming messages to the voices in its control. When all voices are sounding and a new noteOn is encountered, the <a class="el" href="classstk_1_1Voicer.html" title="STK voice manager class.">stk::Voicer</a> interrupts the oldest sounding voice. The user is responsible for creating and deleting all instrument instances.</p>
<p>In the following example, we modify the <code>controlbee.cpp</code> program to make use of three <a class="el" href="classstk_1_1BeeThree.html" title="STK Hammond-oid organ FM synthesis instrument.">stk::BeeThree</a> instruments, all controlled using a <a class="el" href="classstk_1_1Voicer.html" title="STK voice manager class.">stk::Voicer</a>.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// threebees.cpp STK tutorial program</span>

<span class="preprocessor">#include &quot;BeeThree.h&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="RtAudio_8h.html">RtAudio.h</a>&quot;</span>
<span class="preprocessor">#include &quot;Messager.h&quot;</span>
<span class="preprocessor">#include &quot;Voicer.h&quot;</span>
<span class="preprocessor">#include &quot;SKINI.msg&quot;</span>

<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="keyword">using</span> std::min;

<span class="keyword">using namespace </span>stk;

<span class="comment">// The TickData structure holds all the class instances and data that</span>
<span class="comment">// are shared by the various processing functions.</span>
<span class="keyword">struct </span>TickData {
  Voicer voicer;
  Messager messager;
  Skini::Message message;
  <span class="keywordtype">int</span> counter;
  <span class="keywordtype">bool</span> haveMessage;
  <span class="keywordtype">bool</span> done;

  <span class="comment">// Default constructor.</span>
  TickData()
    : counter(0), haveMessage(false), done( false ) {}
};

<span class="preprocessor">#define DELTA_CONTROL_TICKS 64 // default sample frames between control input checks</span>
<span class="preprocessor"></span>
<span class="comment">// The processMessage() function encapsulates the handling of control</span>
<span class="comment">// messages.  It can be easily relocated within a program structure</span>
<span class="comment">// depending on the desired scheduling scheme.</span>
<span class="keywordtype">void</span> processMessage( TickData* data )
{
  <span class="keyword">register</span> StkFloat value1 = data-&gt;message.floatValues[0];
  <span class="keyword">register</span> StkFloat value2 = data-&gt;message.floatValues[1];

  <span class="keywordflow">switch</span>( data-&gt;message.type ) {

  <span class="keywordflow">case</span> __SK_Exit_:
    data-&gt;done = <span class="keyword">true</span>;
    <span class="keywordflow">return</span>;

  <span class="keywordflow">case</span> __SK_NoteOn_:
    <span class="keywordflow">if</span> ( value2 == 0.0 ) <span class="comment">// velocity is zero ... really a NoteOff</span>
      data-&gt;voicer.noteOff( value1, 64.0 );
    <span class="keywordflow">else</span> { <span class="comment">// a NoteOn</span>
      data-&gt;voicer.noteOn( value1, value2 );
    }
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> __SK_NoteOff_:
    data-&gt;voicer.noteOff( value1, value2 );
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> __SK_ControlChange_:
    data-&gt;voicer.controlChange( (<span class="keywordtype">int</span>) value1, value2 );
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> __SK_AfterTouch_:
    data-&gt;voicer.controlChange( 128, value1 );

  <span class="keywordflow">case</span> __SK_PitchChange_:
    data-&gt;voicer.setFrequency( value1 );
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> __SK_PitchBend_:
    data-&gt;voicer.pitchBend( value1 );

  } <span class="comment">// end of switch</span>

  data-&gt;haveMessage = <span class="keyword">false</span>;
  <span class="keywordflow">return</span>;
}

<span class="comment">// This tick() function handles sample computation and scheduling of</span>
<span class="comment">// control updates.  It will be called automatically when the system</span>
<span class="comment">// needs a new buffer of audio samples.</span>
<span class="keywordtype">int</span> tick( <span class="keywordtype">void</span> *outputBuffer, <span class="keywordtype">void</span> *inputBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nBufferFrames,
         <span class="keywordtype">double</span> streamTime, <a class="code" href="RtAudio_8h.html#a80e306d363583da3b0a1b65d9b57c806" title="RtAudio stream status (over- or underflow) flags.">RtAudioStreamStatus</a> status, <span class="keywordtype">void</span> *dataPointer )
{
  TickData *data = (TickData *) dataPointer;
  <span class="keyword">register</span> StkFloat *samples = (StkFloat *) outputBuffer;
  <span class="keywordtype">int</span> counter, nTicks = (int) nBufferFrames;

  <span class="keywordflow">while</span> ( nTicks &gt; 0 &amp;&amp; !data-&gt;done ) {

    <span class="keywordflow">if</span> ( !data-&gt;haveMessage ) {
      data-&gt;messager.popMessage( data-&gt;message );
      <span class="keywordflow">if</span> ( data-&gt;message.type &gt; 0 ) {
        data-&gt;counter = (long) (data-&gt;message.time * Stk::sampleRate());
        data-&gt;haveMessage = <span class="keyword">true</span>;
      }
      <span class="keywordflow">else</span>
        data-&gt;counter = DELTA_CONTROL_TICKS;
    }

    counter = min( nTicks, data-&gt;counter );
    data-&gt;counter -= counter;

    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i&lt;counter; i++ ) {
      *samples++ = data-&gt;voicer.tick();
      nTicks--;
    }
    <span class="keywordflow">if</span> ( nTicks == 0 ) <span class="keywordflow">break</span>;

    <span class="comment">// Process control messages.</span>
    <span class="keywordflow">if</span> ( data-&gt;haveMessage ) processMessage( data );
  }

  <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span> main()
{
  <span class="comment">// Set the global sample rate and rawwave path before creating class instances.</span>
  Stk::setSampleRate( 44100.0 );
  Stk::setRawwavePath( <span class="stringliteral">&quot;../../rawwaves/&quot;</span> );

  <span class="keywordtype">int</span> i;
  TickData data;
  <a class="code" href="classRtAudio.html" title="Realtime audio i/o C++ classes.">RtAudio</a> dac;
  Instrmnt *instrument[3];
  <span class="keywordflow">for</span> ( i=0; i&lt;3; i++ ) instrument[i] = 0;

  <span class="comment">// Figure out how many bytes in an StkFloat and setup the RtAudio stream.</span>
  <a class="code" href="structRtAudio_1_1StreamParameters.html" title="The structure for specifying input or ouput stream parameters.">RtAudio::StreamParameters</a> parameters;
  parameters.<a class="code" href="structRtAudio_1_1StreamParameters.html#ab3c72bcf3ef12149ae9a4fb597cc5489">deviceId</a> = dac.<a class="code" href="classRtAudio.html#a3a3f3dbe13ea696b521e49cdaaa357bc" title="A function that returns the index of the default output device.">getDefaultOutputDevice</a>();
  parameters.<a class="code" href="structRtAudio_1_1StreamParameters.html#a88a10091b6e284e21235cc6f25332ebd">nChannels</a> = 1;
  <a class="code" href="RtAudio_8h.html#aafca92882d25915560018873221e44b8" title="RtAudio data format type.">RtAudioFormat</a> format = ( <span class="keyword">sizeof</span>(StkFloat) == 8 ) ? RTAUDIO_FLOAT64 : RTAUDIO_FLOAT32;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufferFrames = RT_BUFFER_SIZE;
  <span class="keywordflow">try</span> {
    dac.<a class="code" href="classRtAudio.html#afacc99740fa4c5606fb35467cdea6da8" title="A public function for opening a stream with the specified parameters.">openStream</a>( &amp;parameters, NULL, format, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)Stk::sampleRate(), &amp;bufferFrames, &amp;tick, (<span class="keywordtype">void</span> *)&amp;data );
  }
  <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html" title="Exception handling class for RtAudio &amp;amp; RtMidi.">RtError</a> &amp;error ) {
    error.<a class="code" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">printMessage</a>();
    <span class="keywordflow">goto</span> cleanup;
  }

  <span class="keywordflow">try</span> {
    <span class="comment">// Define and load the BeeThree instruments</span>
    <span class="keywordflow">for</span> ( i=0; i&lt;3; i++ )
      instrument[i] = <span class="keyword">new</span> BeeThree();
  }
  <span class="keywordflow">catch</span> ( StkError &amp; ) {
    <span class="keywordflow">goto</span> cleanup;
  }

  <span class="comment">// &quot;Add&quot; the instruments to the voicer.</span>
  <span class="keywordflow">for</span> ( i=0; i&lt;3; i++ )
    data.voicer.addInstrument( instrument[i] );

  <span class="keywordflow">if</span> ( data.messager.startStdInput() == false )
    <span class="keywordflow">goto</span> cleanup;

  <span class="keywordflow">try</span> {
    dac.<a class="code" href="classRtAudio.html#aec017a89629ccef66a90b60be22a2f80" title="A function that starts a stream.">startStream</a>();
  }
  <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html" title="Exception handling class for RtAudio &amp;amp; RtMidi.">RtError</a> &amp;error ) {
    error.<a class="code" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">printMessage</a>();
    <span class="keywordflow">goto</span> cleanup;
  }

  <span class="comment">// Block waiting until callback signals done.</span>
  <span class="keywordflow">while</span> ( !data.done )
    Stk::sleep( 100 );
  
  <span class="comment">// Shut down the callback and output stream.</span>
  <span class="keywordflow">try</span> {
    dac.<a class="code" href="classRtAudio.html#a90d599002ad32cf250a4cb866f2cc93a" title="A function that closes a stream and frees any associated stream memory.">closeStream</a>();
  }
  <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html" title="Exception handling class for RtAudio &amp;amp; RtMidi.">RtError</a> &amp;error ) {
    error.<a class="code" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">printMessage</a>();
  }

 cleanup:
  <span class="keywordflow">for</span> ( i=0; i&lt;3; i++ ) <span class="keyword">delete</span> instrument[i];

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>We have written this program to accept control messages from <code>STDIN</code>. Assuming the program is compiled as <code>threebees</code>, the three-voice SKINI scorefile <a href="tutorial/bachfugue.ski"><code>bachfugue.ski</code></a> (located in the <code>scores</code> directory with the examples) can be redirected to the program as:</p>
<div class="fragment"><pre class="fragment">threebees &lt; scores/bachfugue.ski
</pre></div><p>For more fun, surf to <a href="http://kern.humdrum.net/">Kern Scores</a> for a huge assortment of other scorefiles that can be downloaded in the SKINI format.</p>
<p>Another easy extension would be to add the <code><a class="el" href="classstk_1_1Messager.html#a49877209a4ee08e684de82a73f2d9df9" title="Start MIDI input, with optional device and port identifiers.">stk::Messager::startMidiInput()</a></code> function to the program and then play the instruments via a MIDI keyboard.</p>
<p>[<a href="tutorial.html">Main tutorial page</a>] </p>
</div>
<HR>

<table>
  <tr><td><A HREF="http://ccrma.stanford.edu/software/stk/"><I>The Synthesis ToolKit in C++ (STK)</I></A></td></tr>
  <tr><td>&copy;1995-2011 Perry R. Cook and Gary P. Scavone. All Rights Reserved.</td></tr>
</table>

</BODY>
</HTML>
