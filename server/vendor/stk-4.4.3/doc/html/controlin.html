<HTML>
<HEAD>
<TITLE>The Synthesis ToolKit in C++ (STK)</TITLE>
<LINK HREF="doxygen.css" REL="stylesheet" TYPE="text/css">
</HEAD>
<BODY BGCOLOR="#FFFFFF">
<CENTER>
<img src="princeton.gif"> &nbsp; <img src="ccrma.gif"> &nbsp; <img src="mcgill.gif"><P>
<a class="qindex" href="index.html">Home</a> &nbsp; <a class="qindex" href="information.html">Information</a> &nbsp; <a class="qindex" href="classes.html">Classes</a> &nbsp; <a class="qindex" href="download.html">Download</a> &nbsp; <a class="qindex" href="usage.html">Usage</a> &nbsp; <a class="qindex" href="maillist.html">Mail List</a> &nbsp; <a class="qindex" href="system.html">Requirements</a> &nbsp; <a class="qindex" href="links.html">Links</a> &nbsp; <a class="qindex" href="faq.html">FAQ</a> &nbsp; <a class="qindex" href="tutorial.html">Tutorial</a></CENTER>
<HR>
<!-- Generated by Doxygen 1.6.2 -->
<div class="contents">


<h1><a class="anchor" id="controlin">Control Input </a></h1><p>Each Synthesis ToolKit instrument exposes its relevant control parameters via public functions such as setFrequency() and controlChange(). Programmers are free to implement the control scheme of their choice in exposing those parameters to the user.</p>
<p>A text-based control protocol called <a href="skini.html">SKINI</a> is provided with the Synthesis ToolKit. SKINI extends the MIDI protocol in incremental ways, providing a text-based messaging scheme in human-readable format and making use of floating-point numbers wherever possible. Each SKINI message consists of a message type (e.g., NoteOn, PitchBend), a time specification (absolute or delta), a channel number (scanned as a long integer), and a maximum of two subsequent message-specific field values. Knowing this, it should be relatively clear what the following SKINI "scorefile" specifies:</p>
<div class="fragment"><pre class="fragment">NoteOn          0.000082  2  55.0  82.3
NoteOff         1.000000  2  55.0  64.0
NoteOn          0.000082  2  69.0  82.8
StringDetune    0.100000  2  10.0
StringDetune    0.100000  2  30.0
StringDetune    0.100000  2  50.0
StringDetune    0.100000  2  40.0
StringDetune    0.100000  2  22.0
StringDetune    0.100000  2  12.0
NoteOff         1.000000  2  69.0  64.0
</pre></div><p>MIDI messages are easily represented within the SKINI protocol.</p>
<p>The class <a class="el" href="classstk_1_1Messager.html" title="STK input control message parser.">stk::Messager</a> can be used to acquire and parse MIDI messages from a MIDI device and SKINI messages from STDIN and socket connections. Incoming messages are acquired asynchronously and saved to an internal message queue of <a class="el" href="structstk_1_1Skini_1_1Message.html" title="A message structure to store and pass parsed SKINI messages.">stk::Skini::Message</a> types (MIDI messages are converted to the <a class="el" href="classstk_1_1Skini.html" title="STK SKINI parsing class.">stk::Skini</a>:Message format). The user then uses the <a class="el" href="classstk_1_1Messager.html" title="STK input control message parser.">stk::Messager</a>:popMessage() function to retrieve incoming control messages. This function does not block, instead returning a message type of zero when no more messages are in the queue. Many of the example programs included with the ToolKit distribution use a <a class="el" href="classstk_1_1Messager.html" title="STK input control message parser.">stk::Messager</a> instance to accept control input from the accompanying tcl/tk graphical user interfaces, from external MIDI devices, or from SKINI scorefiles.</p>
<p>In the following example, we'll modify the <code>bethree.cpp</code> program from the previous tutorial chapter and incorporate a <a class="el" href="classstk_1_1Messager.html" title="STK input control message parser.">stk::Messager</a> class to allow control via SKINI messages read from a SKINI file.</p>
<div class="fragment"><pre class="fragment"><span class="comment">// controlbee.cpp STK tutorial program</span>

<span class="preprocessor">#include &quot;BeeThree.h&quot;</span>
<span class="preprocessor">#include &quot;<a class="code" href="RtAudio_8h.html">RtAudio.h</a>&quot;</span>
<span class="preprocessor">#include &quot;Messager.h&quot;</span>
<span class="preprocessor">#include &quot;SKINI.msg&quot;</span>
<span class="preprocessor">#include &lt;math.h&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="keyword">using</span> std::min;

<span class="keyword">using namespace </span>stk;

<span class="keywordtype">void</span> usage(<span class="keywordtype">void</span>) {
  <span class="comment">// Error function in case of incorrect command-line</span>
  <span class="comment">// argument specifications.</span>
  std::cout &lt;&lt; <span class="stringliteral">&quot;\nuseage: controlbee file\n&quot;</span>;
  std::cout &lt;&lt; <span class="stringliteral">&quot;    where file = a SKINI scorefile.\n\n&quot;</span>;
  exit(0);
}

<span class="comment">// The TickData structure holds all the class instances and data that</span>
<span class="comment">// are shared by the various processing functions.</span>
<span class="keyword">struct </span>TickData {
  Instrmnt *instrument;
  Messager messager;
  Skini::Message message;
  <span class="keywordtype">int</span> counter;
  <span class="keywordtype">bool</span> haveMessage;
  <span class="keywordtype">bool</span> done;

  <span class="comment">// Default constructor.</span>
  TickData()
    : instrument(0), counter(0), haveMessage(false), done( false ) {}
};

<span class="preprocessor">#define DELTA_CONTROL_TICKS 64 // default sample frames between control input checks</span>
<span class="preprocessor"></span>
<span class="comment">// The processMessage() function encapsulates the handling of control</span>
<span class="comment">// messages.  It can be easily relocated within a program structure</span>
<span class="comment">// depending on the desired scheduling scheme.</span>
<span class="keywordtype">void</span> processMessage( TickData* data )
{
  <span class="keyword">register</span> StkFloat value1 = data-&gt;message.floatValues[0];
  <span class="keyword">register</span> StkFloat value2 = data-&gt;message.floatValues[1];

  <span class="keywordflow">switch</span>( data-&gt;message.type ) {

  <span class="keywordflow">case</span> __SK_Exit_:
    data-&gt;done = <span class="keyword">true</span>;
    <span class="keywordflow">return</span>;

  <span class="keywordflow">case</span> __SK_NoteOn_:
    <span class="keywordflow">if</span> ( value2 == 0.0 ) <span class="comment">// velocity is zero ... really a NoteOff</span>
      data-&gt;instrument-&gt;noteOff( 0.5 );
    <span class="keywordflow">else</span> { <span class="comment">// a NoteOn</span>
      StkFloat frequency = 220.0 * pow( 2.0, (value1 - 57.0) / 12.0 ); 
      data-&gt;instrument-&gt;noteOn( frequency, value2 * ONE_OVER_128 );
    }
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> __SK_NoteOff_:
    data-&gt;instrument-&gt;noteOff( value2 * ONE_OVER_128 );
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> __SK_ControlChange_:
    data-&gt;instrument-&gt;controlChange( (<span class="keywordtype">int</span>) value1, value2 );
    <span class="keywordflow">break</span>;

  <span class="keywordflow">case</span> __SK_AfterTouch_:
    data-&gt;instrument-&gt;controlChange( 128, value1 );

  } <span class="comment">// end of switch</span>

  data-&gt;haveMessage = <span class="keyword">false</span>;
  <span class="keywordflow">return</span>;
}

<span class="comment">// This tick() function handles sample computation and scheduling of</span>
<span class="comment">// control updates.  It will be called automatically when the system</span>
<span class="comment">// needs a new buffer of audio samples.</span>
<span class="keywordtype">int</span> tick( <span class="keywordtype">void</span> *outputBuffer, <span class="keywordtype">void</span> *inputBuffer, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nBufferFrames,
         <span class="keywordtype">double</span> streamTime, <a class="code" href="RtAudio_8h.html#a80e306d363583da3b0a1b65d9b57c806" title="RtAudio stream status (over- or underflow) flags.">RtAudioStreamStatus</a> status, <span class="keywordtype">void</span> *dataPointer )
{
  TickData *data = (TickData *) dataPointer;
  <span class="keyword">register</span> StkFloat *samples = (StkFloat *) outputBuffer;
  <span class="keywordtype">int</span> counter, nTicks = (int) nBufferFrames;

  <span class="keywordflow">while</span> ( nTicks &gt; 0 &amp;&amp; !data-&gt;done ) {

    <span class="keywordflow">if</span> ( !data-&gt;haveMessage ) {
      data-&gt;messager.popMessage( data-&gt;message );
      <span class="keywordflow">if</span> ( data-&gt;message.type &gt; 0 ) {
        data-&gt;counter = (long) (data-&gt;message.time * Stk::sampleRate());
        data-&gt;haveMessage = <span class="keyword">true</span>;
      }
      <span class="keywordflow">else</span>
        data-&gt;counter = DELTA_CONTROL_TICKS;
    }

    counter = min( nTicks, data-&gt;counter );
    data-&gt;counter -= counter;

    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i&lt;counter; i++ ) {
      *samples++ = data-&gt;instrument-&gt;tick();
      nTicks--;
    }
    <span class="keywordflow">if</span> ( nTicks == 0 ) <span class="keywordflow">break</span>;

    <span class="comment">// Process control messages.</span>
    <span class="keywordflow">if</span> ( data-&gt;haveMessage ) processMessage( data );
  }

  <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] )
{
  <span class="keywordflow">if</span> ( argc != 2 ) usage();

  <span class="comment">// Set the global sample rate and rawwave path before creating class instances.</span>
  Stk::setSampleRate( 44100.0 );
  Stk::setRawwavePath( <span class="stringliteral">&quot;../../rawwaves/&quot;</span> );

  TickData data;
  <a class="code" href="classRtAudio.html" title="Realtime audio i/o C++ classes.">RtAudio</a> dac;

  <span class="comment">// Figure out how many bytes in an StkFloat and setup the RtAudio stream.</span>
  <a class="code" href="structRtAudio_1_1StreamParameters.html" title="The structure for specifying input or ouput stream parameters.">RtAudio::StreamParameters</a> parameters;
  parameters.<a class="code" href="structRtAudio_1_1StreamParameters.html#ab3c72bcf3ef12149ae9a4fb597cc5489">deviceId</a> = dac.<a class="code" href="classRtAudio.html#a3a3f3dbe13ea696b521e49cdaaa357bc" title="A function that returns the index of the default output device.">getDefaultOutputDevice</a>();
  parameters.<a class="code" href="structRtAudio_1_1StreamParameters.html#a88a10091b6e284e21235cc6f25332ebd">nChannels</a> = 1;
  <a class="code" href="RtAudio_8h.html#aafca92882d25915560018873221e44b8" title="RtAudio data format type.">RtAudioFormat</a> format = ( <span class="keyword">sizeof</span>(StkFloat) == 8 ) ? RTAUDIO_FLOAT64 : RTAUDIO_FLOAT32;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bufferFrames = RT_BUFFER_SIZE;
  <span class="keywordflow">try</span> {
    dac.<a class="code" href="classRtAudio.html#afacc99740fa4c5606fb35467cdea6da8" title="A public function for opening a stream with the specified parameters.">openStream</a>( &amp;parameters, NULL, format, (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)Stk::sampleRate(), &amp;bufferFrames, &amp;tick, (<span class="keywordtype">void</span> *)&amp;data );
  }
  <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html" title="Exception handling class for RtAudio &amp;amp; RtMidi.">RtError</a> &amp;error ) {
    error.<a class="code" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">printMessage</a>();
    <span class="keywordflow">goto</span> cleanup;
  }

  <span class="keywordflow">try</span> {
    <span class="comment">// Define and load the BeeThree instrument</span>
    data.instrument = <span class="keyword">new</span> BeeThree();
  }
  <span class="keywordflow">catch</span> ( StkError &amp; ) {
    <span class="keywordflow">goto</span> cleanup;
  }

  <span class="keywordflow">if</span> ( data.messager.setScoreFile( argv[1] ) == false )
    <span class="keywordflow">goto</span> cleanup;

  <span class="keywordflow">try</span> {
    dac.<a class="code" href="classRtAudio.html#aec017a89629ccef66a90b60be22a2f80" title="A function that starts a stream.">startStream</a>();
  }
  <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html" title="Exception handling class for RtAudio &amp;amp; RtMidi.">RtError</a> &amp;error ) {
    error.<a class="code" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">printMessage</a>();
    <span class="keywordflow">goto</span> cleanup;
  }

  <span class="comment">// Block waiting until callback signals done.</span>
  <span class="keywordflow">while</span> ( !data.done )
    Stk::sleep( 100 );
  
  <span class="comment">// Shut down the output stream.</span>
  <span class="keywordflow">try</span> {
    dac.<a class="code" href="classRtAudio.html#a90d599002ad32cf250a4cb866f2cc93a" title="A function that closes a stream and frees any associated stream memory.">closeStream</a>();
  }
  <span class="keywordflow">catch</span> ( <a class="code" href="classRtError.html" title="Exception handling class for RtAudio &amp;amp; RtMidi.">RtError</a> &amp;error ) {
    error.<a class="code" href="classRtError.html#a251dcdac396c998c91706dd2dd3b8bfc" title="Prints thrown error message to stderr.">printMessage</a>();
  }

 cleanup:
  <span class="keyword">delete</span> data.instrument;

  <span class="keywordflow">return</span> 0;
}
</pre></div><p>A realtime control message will usually have a delta time of zero, in which case it is processed as soon as possible. Non-realtime messages, normally from a scorefile, will usually have non-zero delta times. The scheme used in this example is designed to work for both scorefile and realtime input types. When no message is available from the queue, the instrument is "ticked" for DELTA_CONTROL_TICKS and then the queue is checked again. The value of DELTA_CONTROL_TICKS roughly defines the program "control rate" in a realtime context, though multiple available messages in the queue are processed in immediate succession when their delta time values are zero.</p>
<p>The <code>processMessage()</code> function centralizes the handling of control messages. Other control update schemes can be implemented, perhaps using a separate thread or in the <code>main()</code> function, and this function should work in any context.</p>
<p>Assuming the program is compiled as <code>controlbee</code> and the SKINI scorefile <a href="tutorial/bookert.ski"><code>bookert.ski</code></a> is in the <code>scores</code> directory, the program can be run as:</p>
<div class="fragment"><pre class="fragment">controlbee scores/bookert.ski
</pre></div><p>Only a few basic SKINI message type case statements are included in this example. It is easy to extend the program to support a much more elaborate set of instrument control parameters.</p>
<p>This example could also be easily extended to accept "realtime" control input messages via pipe, socket or MIDI connections. The <a class="el" href="classstk_1_1Messager.html" title="STK input control message parser.">stk::Messager</a> class provides <a class="el" href="classstk_1_1Messager.html#a04c70f97c899b03f3b7c1158943106e3" title="Initiate the &quot;realtime&quot; retreival from stdin of control messages into the...">stk::Messager::startStdInput()</a>, <a class="el" href="classstk_1_1Messager.html#a180fd45d109a2058ecbd6a629b979cb7" title="Start a socket server, accept connections, and read &quot;realtime&quot; control...">stk::Messager::startSocketInput()</a>, and <a class="el" href="classstk_1_1Messager.html#a49877209a4ee08e684de82a73f2d9df9" title="Start MIDI input, with optional device and port identifiers.">stk::Messager::startMidiInput()</a> functions for this purpose.</p>
<p>[<a href="tutorial.html">Main tutorial page</a>] &nbsp; [<a href="multichannel.html">Next tutorial</a>] </p>
</div>
<HR>

<table>
  <tr><td><A HREF="http://ccrma.stanford.edu/software/stk/"><I>The Synthesis ToolKit in C++ (STK)</I></A></td></tr>
  <tr><td>&copy;1995-2011 Perry R. Cook and Gary P. Scavone. All Rights Reserved.</td></tr>
</table>

</BODY>
</HTML>
